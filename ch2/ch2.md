# go语言圣经
## 程序结构
### 声明
1. 四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明
2. 包一级声明语句声明的名字可在整个包对应的每个源文件中访问,局部声明的名字就只能在函数内部很小的范围被访问

### 变量
1. var 变量名字 类型 = 表达式
2. 零值初始化机制,数值类型零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil
3. 同时声明一组变量,用逗号分隔
4. 简短变量声明 := ,只有对已经在同级词法域声明过的变量才和赋值操作语句等价
5. 一个指针的值是另一个变量的地址,指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”
6. 聚合类型每个成员,可以被取地址
7. 函数返回局部变量的地址也是安全的
8. 将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
9. 我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名
10. 指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值
11. 另一个创建变量的方法是调用用内建的new函数,new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T
12. 变量的生命周期指的是在程序运行期间变量有效存在的时间间隔
13. 从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果
14. 一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
15. 局部变量从函数中逃逸,该局部变量必须在堆上分配

### 赋值
1. 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值,用法交换两个变量的值
2. 最大公约数（GCD算法）,计算斐波纳契数列（Fibonacci）的第N个数 更加简洁
3. 表达式太复杂的话，应该尽量避免过度使用元组赋值;调用一个有多个返回值的函数,可以使用元组赋值,额外的返回值来表达某种错误类型,可以用下划线空白标识符_来丢弃不需要的值
4. 程序中还有很多地方会发生隐式的赋值行为:函数传参,复合类型的字面量

### 类型
1. type 类型名字 底层类型 类型声明语句
2. 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用
3. 命名类型还可以为该类型的值定义新的行为
4. 许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印
5. 显式转型操作,每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型

### 包和文件
1. Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用
2. 每个包都对应一个独立的名字空间
3. 如果一个名字是大写字母开头的，那么该名字是导出的

### 包和文件-导入包习题
1. 每个包都有一个全局唯一的导入路径
2. 按照惯例，一个包的名字和包的导入路径的最后一个字段相同

### 包和文件-包初始化习题
1. 解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化
2. 包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化
3. init初始化函数,在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用
4. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次,在main函数执行之前，所有依赖的包都已经完成初始化工作了
5. 一个数字中含二进制1bit的个数算法,统计出一个int型数值中比特值为1的比特个数

### 包和文件-作用域
1. 一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量
2. 一个变量的生命周期是指程序运行时变量存在的有效时间段;声明语句的作用域对应的是一个源代码的文本区域,它是一个编译时的属性
3. 句法块是由花括弧所包含;我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。
4. 全局作用域 包级语法域 源文件级的作用域 局部作用域 函数级的作用域
5. 从最内层的词法域向全局的作用域查找。内部的会覆盖外部的,如果查找失败，则报告“未声明的名字”这样的错误
6. 词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明
7. 隐式词法域, 比如:for循环 函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域
8. Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。
9. 要特别注意短变量声明语句的作用域范围,虽然变量在外部已经声明过，但是:=语句还是将变量重新声明为新的局部变量，避免出现类似潜在的问题,通过单独声明变量，来避免使用:=