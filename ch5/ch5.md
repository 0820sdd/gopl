# go语言圣经
## 四、函数
###  Go语言圣经-匿名函数
1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值
2. 通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量
3. 函数值不仅仅是一串代码，还记录了状态，意味着匿名函数和父函数中，存在变量引用，函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包
4. 给定一些计算机课程，每个课程都有前置课程，只有完成了前置课程才可以开始当前课程的学习,这类问题被称作拓扑排序。从概念上说，前置条件可以构成有向图。

### Go语言圣经-可变参数习题
1. 参数数量可变的函数称为为可变参数函数,例子就是fmt.Printf和类似函数
2. 参数列表的最后一个参数类型之前加上省略符号“...”
3. 虽然在可变参数函数内部，...int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的
类型不同:fmt.Printf("%T\n", f)
4. 函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串
5. interface{}表示函数的最后一个参数可以接收任意类型

### Go语言圣经-Deferred函数
1. 只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束

2. defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后
3. defer语句会先调用，defer后面的函数会最后调用，两层函数，配合返回匿名函数函数值实现trace功能
 defer trace("bigSlowOperation")()
4. http响应写入文件 n, err = io.Copy(f, resp.Body)

### go语言圣经-Panic异常
1. 当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）
2. 不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。
3. 由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致，对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic
4. 为了方便诊断问题，runtime包允许输出堆栈信息

### Go语言圣经-Recover捕获异常
1. 通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作
2. 安全的做法是有选择性的recover
3. 在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回

